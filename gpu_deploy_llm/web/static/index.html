<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Deploy LLM - Dashboard</title>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --text-primary: #e8e8e8;
            --text-secondary: #a0a0a0;
            --accent: #00d9ff;
            --success: #00ff88;
            --warning: #ffaa00;
            --error: #ff4444;
        }
        @media (prefers-color-scheme: light) {
            :root {
                --bg-primary: #f5f5f5;
                --bg-secondary: #ffffff;
                --bg-card: #e8e8e8;
                --text-primary: #1a1a1a;
                --text-secondary: #666666;
            }
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.5;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--bg-card);
        }
        .header h1 { font-size: 1.5rem; font-weight: 600; }
        .header-actions { display: flex; gap: 10px; align-items: center; }
        .btn {
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: opacity 0.2s, transform 0.1s;
        }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
        .card {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .card h2 {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .section { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--bg-card); }
        .section:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
        .status-row { display: flex; align-items: center; margin-bottom: 8px; font-size: 0.9rem; }
        .status-dot {
            width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; flex-shrink: 0;
        }
        .status-dot.green { background: var(--success); box-shadow: 0 0 6px var(--success); }
        .status-dot.yellow { background: var(--warning); box-shadow: 0 0 6px var(--warning); }
        .status-dot.red { background: var(--error); box-shadow: 0 0 6px var(--error); }
        .status-dot.gray { background: var(--text-secondary); }
        .providers { display: flex; gap: 20px; margin-top: 10px; }
        .provider { display: flex; align-items: center; font-size: 0.85rem; }
        .config-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .config-row > div { flex: 1; }
        .config-row label { display: block; font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 4px; }
        select, input {
            background: var(--bg-card);
            border: 1px solid transparent;
            color: var(--text-primary);
            padding: 8px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            width: 100%;
        }
        select:focus, input:focus { outline: none; border-color: var(--accent); }
        .progress-bar { height: 6px; background: var(--bg-card); border-radius: 3px; overflow: hidden; margin-bottom: 12px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--success)); transition: width 0.3s; }
        .step { display: flex; align-items: center; margin-bottom: 6px; font-size: 0.85rem; }
        .step-icon { width: 18px; height: 18px; margin-right: 8px; display: flex; align-items: center; justify-content: center; font-size: 0.9rem; }
        .step.complete .step-icon::before { content: "✓"; color: var(--success); }
        .step.running .step-icon::before { content: "◐"; color: var(--accent); animation: spin 1s linear infinite; }
        .step.pending .step-icon::before { content: "○"; color: var(--text-secondary); }
        .step.failed .step-icon::before { content: "✗"; color: var(--error); }
        .step.skipped .step-icon::before { content: "–"; color: var(--text-secondary); }
        @keyframes spin { to { transform: rotate(360deg); } }
        .logs {
            background: var(--bg-primary);
            border-radius: 6px;
            padding: 12px;
            height: 280px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 0.8rem;
        }
        .log-entry { margin-bottom: 3px; word-break: break-word; }
        .log-entry.info { color: var(--text-primary); }
        .log-entry.warning { color: var(--warning); }
        .log-entry.error { color: var(--error); }
        .log-time { color: var(--text-secondary); margin-right: 8px; font-size: 0.75rem; }
        .result-banner {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-weight: 600;
            display: none;
            font-size: 0.9rem;
        }
        .result-banner.success { background: rgba(0, 255, 136, 0.15); color: var(--success); border: 1px solid var(--success); }
        .result-banner.failure { background: rgba(255, 68, 68, 0.15); color: var(--error); border: 1px solid var(--error); }
        .error-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }
        .btn-small {
            background: var(--accent);
            color: var(--bg-primary);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.8rem;
            transition: opacity 0.2s;
        }
        .btn-small:hover { opacity: 0.9; }
        .btn-small:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-small.btn-danger { background: var(--error); }
        .btn-small.btn-warning { background: var(--warning); color: var(--bg-primary); }
        .action-text { font-size: 0.8rem; font-weight: normal; color: var(--text-secondary); }
        .connection-status { font-size: 0.75rem; color: var(--text-secondary); }
        .connection-status.connected { color: var(--success); }
        .connection-status.disconnected { color: var(--error); }
        /* Session Log styles */
        .session-log { margin-bottom: 20px; }
        .session-log-list { display: flex; flex-direction: column; gap: 8px; }
        .session-log-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-primary);
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
        }
        .session-log-item.active { border-left: 3px solid var(--accent); }
        .session-log-item.success { border-left: 3px solid var(--success); }
        .session-log-item.failed { border-left: 3px solid var(--error); }
        .session-log-item.stopped { border-left: 3px solid var(--text-secondary); }
        .session-log-info { display: flex; align-items: center; gap: 12px; flex: 1; }
        .session-log-id { font-family: monospace; font-size: 0.8rem; color: var(--accent); }
        .session-log-meta { display: flex; gap: 15px; color: var(--text-secondary); font-size: 0.8rem; }
        .session-log-meta span { display: flex; align-items: center; gap: 4px; }
        .session-log-status {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        .session-log-status.running { background: rgba(0, 217, 255, 0.2); color: var(--accent); }
        .session-log-status.provisioning { background: rgba(255, 170, 0, 0.2); color: var(--warning); }
        .session-log-status.stopped { background: rgba(160, 160, 160, 0.2); color: var(--text-secondary); }
        .session-log-status.failed { background: rgba(255, 68, 68, 0.2); color: var(--error); }
        .session-log-status.success { background: rgba(0, 255, 136, 0.2); color: var(--success); }
        .session-log-actions { display: flex; gap: 6px; }
        .session-log-empty { color: var(--text-secondary); font-size: 0.85rem; text-align: center; padding: 20px; }
        .pagination {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 12px;
            font-size: 0.8rem;
        }
        .pagination button {
            background: var(--bg-card);
            border: none;
            color: var(--text-primary);
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .pagination button:hover { background: var(--accent); color: var(--bg-primary); }
        .pagination button:disabled { opacity: 0.3; cursor: not-allowed; }
        .pagination button:disabled:hover { background: var(--bg-card); color: var(--text-primary); }
        .pagination-info { color: var(--text-secondary); }
    </style>
</head>
<body>
    <div class="header">
        <h1>GPU Deploy LLM</h1>
        <div class="header-actions">
            <span class="connection-status" id="connectionStatus">Connecting...</span>
            <button class="btn" id="runBtn" onclick="runTest()">Run Test ▶</button>
        </div>
    </div>

    <div class="result-banner" id="resultBanner">
        <div id="resultText"></div>
        <div class="error-actions" id="errorActions" style="display: none;">
            <span class="action-text">Session may still be active:</span>
            <button class="btn-small btn-danger" onclick="cleanupSession()">Cleanup Now</button>
            <button class="btn-small btn-warning" onclick="dismissError()">Leave Running</button>
        </div>
    </div>

    <div class="grid">
        <!-- Left Column: Status + Config -->
        <div class="card">
            <div class="section">
                <h2>Service Status</h2>
                <div class="status-row">
                    <span class="status-dot gray" id="shopperDot"></span>
                    <span>Shopper: <strong id="shopperStatus">Checking...</strong></span>
                </div>
                <div class="providers">
                    <div class="provider">
                        <span class="status-dot gray" id="vastaiDot"></span>
                        <span>Vast.ai: <span id="vastaiStatus">-</span></span>
                    </div>
                    <div class="provider">
                        <span class="status-dot gray" id="tensordockDot"></span>
                        <span>TensorDock: <span id="tensordockStatus">-</span></span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>Test Configuration</h2>
                <div class="config-row">
                    <div>
                        <label>Model</label>
                        <select id="modelSelect">
                            <option value="TinyLlama/TinyLlama-1.1B-Chat-v1.0">TinyLlama 1.1B</option>
                            <option value="microsoft/phi-2">Phi-2</option>
                            <option value="Qwen/Qwen2-1.5B-Instruct">Qwen2 1.5B</option>
                            <option value="mistralai/Mistral-7B-Instruct-v0.2">Mistral 7B</option>
                        </select>
                    </div>
                    <div>
                        <label>Provider</label>
                        <select id="providerSelect">
                            <option value="">Any</option>
                            <option value="vastai">Vast.ai</option>
                            <option value="tensordock">TensorDock</option>
                        </select>
                    </div>
                </div>
                <div class="config-row">
                    <div>
                        <label>Quantization</label>
                        <select id="quantSelect">
                            <option value="none">FP16</option>
                            <option value="awq">AWQ 4-bit</option>
                            <option value="gptq">GPTQ 4-bit</option>
                        </select>
                    </div>
                    <div>
                        <label>Max $/hr</label>
                        <input type="number" id="maxPrice" value="0.50" step="0.05" min="0.10" max="5.00">
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Progress -->
        <div class="card">
            <h2>Test Progress</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%"></div>
            </div>
            <div id="steps">
                <div class="step pending" data-step="calculate_requirements"><span class="step-icon"></span>Calculate requirements</div>
                <div class="step pending" data-step="query_inventory"><span class="step-icon"></span>Query inventory</div>
                <div class="step pending" data-step="select_offer"><span class="step-icon"></span>Select offer</div>
                <div class="step pending" data-step="create_session"><span class="step-icon"></span>Create session</div>
                <div class="step pending" data-step="wait_for_running"><span class="step-icon"></span>Wait for running</div>
                <div class="step pending" data-step="connect_ssh"><span class="step-icon"></span>Connect SSH</div>
                <div class="step pending" data-step="deploy_vllm"><span class="step-icon"></span>Install & start vLLM</div>
                <div class="step pending" data-step="verify_deployment"><span class="step-icon"></span>Verify deployment</div>
                <div class="step pending" data-step="cleanup"><span class="step-icon"></span>Cleanup</div>
            </div>
        </div>
    </div>

    <div class="card session-log">
        <h2>Session Log</h2>
        <div class="session-log-list" id="sessionLogList">
            <div class="session-log-empty">No sessions yet. Run a test to see sessions here.</div>
        </div>
        <div class="pagination" id="sessionPagination" style="display: none;">
            <button onclick="prevSessionPage()" id="prevPageBtn" disabled>← Prev</button>
            <span class="pagination-info" id="paginationInfo">1 of 1</span>
            <button onclick="nextSessionPage()" id="nextPageBtn" disabled>Next →</button>
        </div>
    </div>

    <div class="card">
        <h2>Live Logs</h2>
        <div class="logs" id="logs"></div>
    </div>

    <script>
        let ws = null;
        let reconnectAttempts = 0;
        let autoScroll = true;
        let currentSessionId = null;

        // Session log state
        let sessionLog = [];
        const SESSIONS_PER_PAGE = 5;
        let sessionPage = 0;
        let sessionRefreshInterval = null;

        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => {
                reconnectAttempts = 0;
                updateConnectionStatus(true);
                addLog('info', 'Connected to dashboard');
                fetchStatus();
            };

            ws.onmessage = (event) => {
                if (event.data === 'ping') { ws.send('pong'); return; }
                try { handleEvent(JSON.parse(event.data)); } catch (e) {}
            };

            ws.onclose = () => {
                updateConnectionStatus(false);
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                reconnectAttempts++;
                setTimeout(connect, delay);
            };
        }

        function updateConnectionStatus(connected) {
            const el = document.getElementById('connectionStatus');
            el.textContent = connected ? 'Connected' : 'Disconnected';
            el.className = 'connection-status ' + (connected ? 'connected' : 'disconnected');
        }

        function handleEvent(data) {
            switch (data.type) {
                case 'status': updateStep(data.step, data.status); updateProgress(data.step_index, data.total_steps); break;
                case 'log': addLog(data.level, data.message); break;
                case 'session': updateSession(data); break;
                case 'result': handleResult(data); break;
                case 'init': try { updateServiceStatus(JSON.parse(data.status)); } catch(e) {} break;
            }
        }

        function updateStep(step, status) {
            const el = document.querySelector(`[data-step="${step}"]`);
            if (el) el.className = `step ${status}`;
        }

        function updateProgress(current, total) {
            document.getElementById('progressBar').style.width = `${((current + 1) / total) * 100}%`;
        }

        function addLog(level, message) {
            const logs = document.getElementById('logs');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${message.replace(/</g, '&lt;')}`;
            logs.appendChild(entry);
            if (autoScroll) logs.scrollTop = logs.scrollHeight;
        }

        function updateSession(data) {
            currentSessionId = data.id;

            // Find existing session in log or add new one
            const existingIdx = sessionLog.findIndex(s => s.id === data.id);
            const existingSession = existingIdx >= 0 ? sessionLog[existingIdx] : null;

            const sessionData = {
                id: data.id,
                status: data.status,
                provider: data.provider,
                gpu_type: data.gpu_type,
                gpu_count: data.gpu_count,
                price_per_hour: data.price_per_hour,
                ssh_host: data.ssh_host,
                ssh_port: data.ssh_port,
                timestamp: existingSession?.timestamp || new Date().toISOString(),
                result: existingSession?.result || null // Preserve result state
            };

            if (existingIdx >= 0) {
                sessionLog[existingIdx] = sessionData;
            } else {
                // Add to beginning (newest first)
                sessionLog.unshift(sessionData);
                sessionPage = 0; // Jump to first page when new session added
            }

            renderSessionLog();
        }

        function updateSessionResult(sessionId, passed, error) {
            const session = sessionLog.find(s => s.id === sessionId);
            if (session) {
                session.result = passed ? 'success' : 'failed';
                session.error = error;
                if (passed) session.status = 'stopped';
                renderSessionLog();
            }
        }

        function renderSessionLog() {
            const list = document.getElementById('sessionLogList');
            const pagination = document.getElementById('sessionPagination');

            if (sessionLog.length === 0) {
                list.innerHTML = '<div class="session-log-empty">No sessions yet. Run a test to see sessions here.</div>';
                pagination.style.display = 'none';
                return;
            }

            // Calculate pagination
            const totalPages = Math.ceil(sessionLog.length / SESSIONS_PER_PAGE);
            const startIdx = sessionPage * SESSIONS_PER_PAGE;
            const endIdx = Math.min(startIdx + SESSIONS_PER_PAGE, sessionLog.length);
            const pageItems = sessionLog.slice(startIdx, endIdx);

            // Render items
            list.innerHTML = pageItems.map(session => {
                const isActive = session.id === currentSessionId && !session.result;
                const statusClass = session.result || (isActive ? 'active' : session.status);
                const displayStatus = session.result === 'success' ? 'completed' :
                                     session.result === 'failed' ? 'failed' : session.status;

                const time = new Date(session.timestamp).toLocaleTimeString();
                const date = new Date(session.timestamp).toLocaleDateString();

                return `
                    <div class="session-log-item ${statusClass}">
                        <div class="session-log-info">
                            <span class="session-log-id">${session.id.substring(0, 12)}...</span>
                            <div class="session-log-meta">
                                <span>${session.provider}</span>
                                <span>${session.gpu_type} x${session.gpu_count}</span>
                                <span>$${session.price_per_hour?.toFixed(3) || '0.00'}/hr</span>
                                <span>${time}</span>
                            </div>
                        </div>
                        <div class="session-log-actions">
                            <span class="session-log-status ${statusClass}">${displayStatus}</span>
                            ${!session.result && session.status !== 'stopped' ?
                                `<button class="btn-small btn-danger" onclick="cleanupSessionById('${session.id}')">Cleanup</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            // Update pagination
            if (totalPages > 1) {
                pagination.style.display = 'flex';
                document.getElementById('paginationInfo').textContent = `${sessionPage + 1} of ${totalPages}`;
                document.getElementById('prevPageBtn').disabled = sessionPage === 0;
                document.getElementById('nextPageBtn').disabled = sessionPage >= totalPages - 1;
            } else {
                pagination.style.display = 'none';
            }
        }

        function prevSessionPage() {
            if (sessionPage > 0) {
                sessionPage--;
                renderSessionLog();
            }
        }

        function nextSessionPage() {
            const totalPages = Math.ceil(sessionLog.length / SESSIONS_PER_PAGE);
            if (sessionPage < totalPages - 1) {
                sessionPage++;
                renderSessionLog();
            }
        }

        async function cleanupSessionById(sessionId) {
            addLog('info', `Initiating cleanup for session ${sessionId.substring(0, 12)}...`);

            try {
                const resp = await fetch('/api/session/cleanup', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({session_id: sessionId})
                });

                if (resp.ok) {
                    addLog('info', 'Cleanup initiated successfully');
                    // Update session in log
                    const session = sessionLog.find(s => s.id === sessionId);
                    if (session) {
                        session.status = 'stopped';
                        session.result = 'stopped';
                        renderSessionLog();
                    }
                    if (sessionId === currentSessionId) {
                        currentSessionId = null;
                        document.getElementById('errorActions').style.display = 'none';
                    }
                } else {
                    const err = await resp.json();
                    addLog('error', `Cleanup failed: ${err.detail || 'Unknown error'}`);
                }
            } catch (e) {
                addLog('error', `Cleanup request failed: ${e.message}`);
            }
        }

        function handleResult(data) {
            const btn = document.getElementById('runBtn');
            btn.disabled = false;
            btn.textContent = 'Run Test ▶';

            const banner = document.getElementById('resultBanner');
            const resultText = document.getElementById('resultText');
            const errorActions = document.getElementById('errorActions');

            // Update session log
            if (currentSessionId) {
                updateSessionResult(currentSessionId, data.passed, data.error);
            }

            banner.style.display = 'block';
            if (data.passed) {
                banner.className = 'result-banner success';
                resultText.textContent = '✓ Test PASSED';
                errorActions.style.display = 'none';
                currentSessionId = null;
            } else {
                banner.className = 'result-banner failure';
                resultText.textContent = `✗ Test FAILED: ${data.error}`;
                // Show cleanup options if we have a session
                if (currentSessionId) {
                    errorActions.style.display = 'flex';
                } else {
                    errorActions.style.display = 'none';
                }
            }
        }

        async function cleanupSession() {
            if (!currentSessionId) {
                addLog('warning', 'No active session to cleanup');
                return;
            }

            document.getElementById('errorActions').style.display = 'none';
            await cleanupSessionById(currentSessionId);
            document.getElementById('resultText').textContent += ' (Cleanup initiated)';
        }

        function dismissError() {
            const sessionId = currentSessionId;
            document.getElementById('errorActions').style.display = 'none';
            document.getElementById('resultText').textContent += ' (Session left running)';
            addLog('warning', `Session ${sessionId ? sessionId.substring(0, 12) + '...' : 'unknown'} left running - remember to cleanup manually`);
            if (sessionId) {
                addLog('info', `To cleanup later: curl -X POST http://localhost:8081/api/session/cleanup -H "Content-Type: application/json" -d '{"session_id":"${sessionId}"}'`);
            }
        }

        function updateServiceStatus(status) {
            const shopperDot = document.getElementById('shopperDot');
            const shopperStatus = document.getElementById('shopperStatus');

            if (status.shopper?.healthy && status.shopper?.ready) {
                shopperDot.className = 'status-dot green';
                shopperStatus.textContent = 'Ready';
            } else if (status.shopper?.healthy) {
                shopperDot.className = 'status-dot yellow';
                shopperStatus.textContent = 'Starting';
            } else {
                shopperDot.className = 'status-dot red';
                shopperStatus.textContent = 'Offline';
            }

            const providers = status.providers || {};
            updateProvider('vastai', providers.vastai);
            updateProvider('tensordock', providers.tensordock);
        }

        function updateProvider(name, count) {
            const dot = document.getElementById(`${name}Dot`);
            const el = document.getElementById(`${name}Status`);
            if (count > 0) {
                dot.className = 'status-dot green';
                el.textContent = `${count}`;
            } else {
                dot.className = 'status-dot gray';
                el.textContent = '0';
            }
        }

        async function fetchStatus() {
            try {
                const resp = await fetch('/api/status');
                updateServiceStatus(await resp.json());
            } catch (e) {}
        }

        async function fetchSessions() {
            try {
                const resp = await fetch('/api/sessions?limit=50');
                const data = await resp.json();

                if (data.sessions && data.sessions.length > 0) {
                    // Merge with existing session log, preserving local result state
                    const existingResults = {};
                    sessionLog.forEach(s => {
                        if (s.result) existingResults[s.id] = s.result;
                    });

                    sessionLog = data.sessions.map(s => ({
                        id: s.id,
                        status: s.status,
                        provider: s.provider,
                        gpu_type: s.gpu_type,
                        gpu_count: s.gpu_count,
                        price_per_hour: s.price_per_hour,
                        ssh_host: s.ssh_host,
                        ssh_port: s.ssh_port,
                        timestamp: s.created_at || new Date().toISOString(),
                        // Preserve local result state or derive from status
                        result: existingResults[s.id] ||
                                (s.status === 'stopped' ? 'stopped' : null) ||
                                (s.status === 'failed' ? 'failed' : null)
                    }));

                    renderSessionLog();
                }
            } catch (e) {
                console.error('Failed to fetch sessions:', e);
            }
        }

        async function runTest() {
            const btn = document.getElementById('runBtn');
            btn.disabled = true;
            btn.textContent = 'Running...';

            // Reset state
            currentSessionId = null;
            document.getElementById('resultBanner').style.display = 'none';
            document.getElementById('errorActions').style.display = 'none';
            document.querySelectorAll('.step').forEach(el => el.className = 'step pending');
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('logs').innerHTML = '';

            const config = {
                model_id: document.getElementById('modelSelect').value,
                quantization: document.getElementById('quantSelect').value,
                max_price: parseFloat(document.getElementById('maxPrice').value),
                reservation_hours: 1,
                provider: document.getElementById('providerSelect').value || null,
                skip_verification: false,
                auto_cleanup: true
            };

            try {
                await fetch('/api/test/run', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(config)
                });
            } catch (e) {
                addLog('error', `Failed to start: ${e.message}`);
                btn.disabled = false;
                btn.textContent = 'Run Test ▶';
            }
        }

        document.getElementById('logs').addEventListener('scroll', function() {
            autoScroll = this.scrollHeight - this.scrollTop <= this.clientHeight + 50;
        });

        connect();
        fetchSessions(); // Load sessions on page load
        setInterval(fetchStatus, 30000);
        setInterval(fetchSessions, 10000); // Refresh sessions every 10s
    </script>
</body>
</html>
